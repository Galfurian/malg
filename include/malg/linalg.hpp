/// @file linalg.hpp
/// @author Enrico Fraccaroli (enry.frak@gmail.com)
/// @brief Linear algebra algorithms.

#pragma once

#include "malg/utility.hpp"
#include "malg/vector.hpp"
#include "malg/matrix.hpp"
#include "malg/math.hpp"

#include <algorithm>
#include <complex>

namespace malg::linalg
{

template <typename T>
inline auto eigenvalue(const MatrixBase<T> &a, const Vector<T> &b)
{
    return b * malg::dot(a, b);
}

/// @brief Computes the transpose of the matrix.
/// @param A the matrix.
/// @return the matrix transposed.
template <typename T>
inline auto transpose(const MatrixBase<T> &A)
{
    Matrix<std::remove_const_t<T>> result(A.cols(), A.rows(), 0.0);
    for (size_type_t r = 0, c; r < A.rows(); ++r)
        for (c = 0; c < A.cols(); ++c)
            result(c, r) = A(r, c);
    return result;
}

/// @brief Computes the transpose of the matrix.
/// @param A the matrix.
/// @return the matrix transposed.
template <typename T>
inline auto exp(const MatrixBase<T> &A)
{
    Matrix<std::remove_const_t<T>> result(A.cols(), A.rows(), 0.0);
    for (size_type_t r = 0, c; r < A.rows(); ++r)
        for (c = 0; c < A.cols(); ++c)
            result(c, r) = std::exp(A(r, c));
    return result;
}

template <typename T>
inline constexpr T factorial(T n)
{
    return (n <= 0) ? 1 : n * factorial<T>(n - 1);
}

template <typename T>
inline auto powm(const MatrixBase<T> &A, long N)
{
    auto R = utility::eye<std::remove_const_t<T>>(A.rows(), A.cols());
    for (long k = 0; k < N; ++k)
        R *= A;
    return R;
}

/// @brief Computes the hermitian transpose of the complex matrix.
/// @param A the matrix.
/// @return the matrix transposed.
template <typename T>
inline auto hermitian_transpose(const MatrixBase<std::complex<T>> &A)
{
    Matrix<std::remove_const_t<T>> result(A.cols(), A.rows(), 0.0);
    for (size_type_t r = 0, c; r < A.rows(); ++r)
        for (c = 0; c < A.cols(); ++c)
            result(c, r) = std::conj(A(r, c));
    return result;
}

/// @brief Computes the transpose and takes the complex conjugate of each entry.
/// @param matrix the matrix.
/// @return the matrix transposed.
template <typename T>
inline auto conjugate_transpose(const MatrixBase<std::complex<T>> &matrix)
{
    Matrix<std::complex<std::remove_const_t<T>>> result(matrix.cols(), matrix.rows(), 0.);
    for (size_type_t r = 0, c; r < matrix.rows(); ++r)
        for (c = 0; c < matrix.cols(); ++c)
            result(c, r) = std::conj(matrix(r, c));
    return result;
}

/// @brief Function to get cofactor of the matrix.
/// @param input the input matrix.
/// @param p the row that must be removed.
/// @param q the column that must be removed.
/// @return An [N-1, N-1] matrix, generated by removing row p and column q from
/// the input matrix.
template <typename T>
inline auto cofactor(const MatrixBase<T> &matrix, size_type_t p, size_type_t q)
{
    // Create the output matrix.
    Matrix<std::remove_const_t<T>> output(matrix.rows() - 1, matrix.cols() - 1, 0);
    // Create the indexing variables.
    size_type_t i, j, row, col;
    // Looping for each element of the matrix.
    for (i = 0, j = 0, row = 0, col = 0; row < matrix.rows(); ++row) {
        for (col = 0; col < matrix.cols(); ++col) {
            // Copying only those element which are not in given row and column.
            if ((row != p) && (col != q)) {
                output(i, j++) = matrix(row, col);
                // When the row is filled, increase row index and reset col index.
                if (j == (matrix.cols() - 1))
                    j = 0, ++i;
            }
        }
    }
    return output;
}

/// @brief Use Gaussian Elimination to create an Upper Diagonalized matrix then
/// multiplying the diagonal to get the determinant.
/// @param matrix the input matrix.
/// @return the determinant of the matrix.
template <typename T>
inline auto determinant(const MatrixBase<T> &matrix)
{
    assert(utility::is_square(matrix) && "Matrix must be square.");
    // Get the size of the matrix.
    const size_type_t N = matrix.cols();
    // Fast exit with a 1x1.
    if (N == 1) {
        return matrix(0, 0);
    }
    // Fast exit with a 2x2.
    if (N == 2) {
        return matrix(0, 0) * matrix(1, 1) - matrix(0, 1) * matrix(1, 0);
    }
    // Fast exit with a 3x3.
    if (N == 3) {
        return matrix(0, 0) * (matrix(1, 1) * matrix(2, 2) - matrix(2, 1) * matrix(1, 2)) -
               matrix(0, 1) * (matrix(1, 0) * matrix(2, 2) - matrix(1, 2) * matrix(2, 0)) +
               matrix(0, 2) * (matrix(1, 0) * matrix(2, 1) - matrix(1, 1) * matrix(2, 0));
    }
    // Fast exit with a 4x4.
    if (N == 4) {
        return matrix(0, 3) * matrix(1, 2) * matrix(2, 1) * matrix(3, 0) - matrix(0, 2) * matrix(1, 3) * matrix(2, 1) * matrix(3, 0) -
               matrix(0, 3) * matrix(1, 1) * matrix(2, 2) * matrix(3, 0) + matrix(0, 1) * matrix(1, 3) * matrix(2, 2) * matrix(3, 0) +
               matrix(0, 2) * matrix(1, 1) * matrix(2, 3) * matrix(3, 0) - matrix(0, 1) * matrix(1, 2) * matrix(2, 3) * matrix(3, 0) -
               matrix(0, 3) * matrix(1, 2) * matrix(2, 0) * matrix(3, 1) + matrix(0, 2) * matrix(1, 3) * matrix(2, 0) * matrix(3, 1) +
               matrix(0, 3) * matrix(1, 0) * matrix(2, 2) * matrix(3, 1) - matrix(0, 0) * matrix(1, 3) * matrix(2, 2) * matrix(3, 1) -
               matrix(0, 2) * matrix(1, 0) * matrix(2, 3) * matrix(3, 1) + matrix(0, 0) * matrix(1, 2) * matrix(2, 3) * matrix(3, 1) +
               matrix(0, 3) * matrix(1, 1) * matrix(2, 0) * matrix(3, 2) - matrix(0, 1) * matrix(1, 3) * matrix(2, 0) * matrix(3, 2) -
               matrix(0, 3) * matrix(1, 0) * matrix(2, 1) * matrix(3, 2) + matrix(0, 0) * matrix(1, 3) * matrix(2, 1) * matrix(3, 2) +
               matrix(0, 1) * matrix(1, 0) * matrix(2, 3) * matrix(3, 2) - matrix(0, 0) * matrix(1, 1) * matrix(2, 3) * matrix(3, 2) -
               matrix(0, 2) * matrix(1, 1) * matrix(2, 0) * matrix(3, 3) + matrix(0, 1) * matrix(1, 2) * matrix(2, 0) * matrix(3, 3) +
               matrix(0, 2) * matrix(1, 0) * matrix(2, 1) * matrix(3, 3) - matrix(0, 0) * matrix(1, 2) * matrix(2, 1) * matrix(3, 3) -
               matrix(0, 1) * matrix(1, 0) * matrix(2, 2) * matrix(3, 3) + matrix(0, 0) * matrix(1, 1) * matrix(2, 2) * matrix(3, 3);
    }
    // We need to create a temporary.
    Matrix<std::remove_const_t<T>> A(matrix);
    // Create the indexing variables.
    size_type_t c, r, k;
    // Initialize the determinant, and create both pivot and ratio variable.
    std::remove_const_t<T> det = 1., pivot, ratio;
    // We convert the temporary to upper triangular form.
    for (c = 0; c < N; ++c) {
        // If we have a negative value on the diagonal, we need to move it
        // somewhere else.
        if (A(c, c) == 0.) {
            // Right now, I'm trying to find a place below the current
            k = c + 1;
            while ((k < A.rows()) && (A(k, c) == 0.))
                k++;
            // If we did not find a non-zero value, we have a singular matrix.
            if (k == A.rows())
                break;
            // Swap the rows.
            utility::swap_rows(A, c, k);
            // Every time we swap rows, we need to change the sign to the
            // determinant.
            det *= -1;
        }
        // Store the pivot.
        pivot = A(c, c);
        for (r = c + 1; r < N; ++r) {
            ratio = A(r, c) / pivot;
            for (k = c; k < N; ++k) {
                A(r, k) -= ratio * A(c, k);
            }
        }
        // Multiply the pivot for the determinant variable.
        det *= pivot;
    }
    return det;
}

/// @brief Computes the adjoint of this matrix.
/// @param matrix the input matrix.
/// @return the adjoint of the matrix.
template <typename T>
inline auto adjoint(const MatrixBase<T> &matrix)
{
    assert(utility::is_square(matrix) && "Matrix must be square.");
    // Get the size of the matrix.
    const size_type_t N = matrix.cols();
    // Return 1.
    if (N == 1)
        return Matrix<std::remove_const_t<T>>(1, 1, 1);
    // Prepare the output matrix.
    Matrix<std::remove_const_t<T>> adj(N, N, 0);
    for (size_type_t i = 0; i < N; ++i) {
        for (size_type_t j = 0; j < N; ++j) {
            // Get cofactor of A[i][j]
            auto support = CofactorView(matrix, i, j);
            // Sign of adj[j][i] positive if sum of row and column indexes is
            // even. Interchanging rows and columns to get the transpose of the
            // cofactor matrix.
            adj(j, i) = (((i + j) % 2 == 0) ? 1 : -1) * linalg::determinant(support);
        }
    }
    return adj;
}

/// @brief Computes the inverse of this matrix.
/// @param matrix the input matrix.
/// @return the inverse of the matrix.
template <typename T>
inline auto inverse(const MatrixBase<T> &matrix)
{
    assert(utility::is_square(matrix) && "Matrix must be square.");
    // Select the right type.
    using data_type_t = std::remove_const_t<malg::extract_common_type_t<T, double>>;
    // Compute the determinant.
    data_type_t det = linalg::determinant(matrix);
    // If determinant is zero, the matrix is singular.
    if (det == 0.) {
        std::cerr << "Matrix is singular.\n";
        return Matrix<data_type_t>();
    }
    // Find adjoint of the matrix.
    auto adjoint = linalg::adjoint(matrix);
    // Create a matrix for the result.
    Matrix<data_type_t> inv(matrix.rows(), matrix.cols(), 0);
    // Find Inverse using formula "inv(A) = adj(A)/det(A)".
    for (size_type_t r = 0; r < matrix.rows(); ++r)
        for (size_type_t c = 0; c < matrix.cols(); ++c)
            inv(r, c) = adjoint(r, c) / det;
    return inv;
}

#if 1
template <typename T>
inline auto qr_decomposition(const Matrix<T> &A)
{
    // Select the right type.
    using data_type_t = std::remove_const_t<malg::extract_common_type_t<T, double>>;
    // This function is required to build the householder.
    static auto make_householder = [](const Vector<data_type_t> &a) {
        // Find prependicular vector to mirror.
        auto u = a / (a[0] + std::copysign(malg::square_norm(a), a[0]));
        u[0]   = 1;
        // Finding Householder projection.
        return utility::eye(a.size(), a.size(), data_type_t(1.)) -
               (utility::to_matrix(u, false) * utility::to_matrix(u, true)) * (2. / malg::element_wise_product(u, u));
    };

    // Initialize matrix R.
    Matrix<data_type_t> R(A);
    // Initialize matrix Q.
    Matrix<data_type_t> Q = utility::eye<data_type_t>(R.rows(), R.rows(), data_type_t(1.));
    // Create hoseholder.
    Matrix<data_type_t> H(R.rows(), R.rows(), data_type_t(0.));

    // Compute Q and R.
    for (size_type_t i = 0; i < (R.cols() - (R.cols() == R.rows())); ++i) {
        // Initialize holder.
        for (size_type_t r = 0; r < H.rows(); ++r)
            for (size_type_t c = 0; c < H.cols(); ++c)
                H(r, c) = (r == c) ? 1 : 0;
        // Calculate Householder matrix i: rows and i: columns from R i: rows and ith column
        View(H, i, -1, i, -1) = make_householder(utility::extract_column(R, i, i, -1));
        // Update Q and R.
        Q = Q * H;
        R = H * R;
    }
    // Clean up the lower triangular elements of R.
    for (size_type_t r = 1; r < R.rows(); ++r)
        for (size_type_t c = 0; c < std::min(r, R.cols()); ++c)
            R(r, c) = 0;
    return std::make_pair(std::move(Q), std::move(R));
}
#else
/// @brief Factorises a hessenberg matrix A as QR, where Q is unitary and R is
/// upper triangular, using N-1 Givens rotations.
/// @param A the input matrix.
/// @return Q and R.
template <typename DT>
auto qr_decomposition(const malg::Matrix<DT> &A)
{
    using T = is_complex_t<DT>;
    // Create the Q matrix.
    auto Q = malg::utility::eye<std::complex<T>>(A.rows(), A.cols(), 1.);
    // Create the R matrix.
    malg::Matrix<std::complex<T>> R = A;
    // Create variables that we will need during the iteration.
    std::complex<T> q, p, qstar, pstar;
    double length;
    for (size_type_t r = 1, c = 0; r < A.rows(); ++r, c = r - 1) {
        // r : The row number
        // c : aiming to zero the element one place below the diagonal.
        if (std::abs(R(r, c)) < std::numeric_limits<T>::epsilon())
            continue;
        // Form the Givens CMatrix
        q      = R(c, c);
        p      = -std::conj(R(r, c));
        length = std::sqrt(std::norm(q) + std::norm(p));
        q /= length, p /= length;
        qstar   = std::conj(q);
        pstar   = std::conj(p);
        auto RR = R;
        auto QQ = Q;
        //  G*T = ( q* -p )     G = (  q  p  )     <--- c
        //        ( p*  q )         ( -p* q* )     <--- r
        for (size_type_t m = 0; m < A.cols(); m++) {
            R(c, m) = (qstar * RR(c, m)) - (p * RR(r, m));
            R(r, m) = (pstar * RR(c, m)) + (q * RR(r, m));
            Q(m, c) = (q * QQ(m, c)) - (pstar * QQ(m, r));
            Q(m, r) = (p * QQ(m, c)) + (qstar * QQ(m, r));
        }
    }
    if constexpr (malg::is_complex_v<DT>) {
        return std::make_pair(Q, R);
    } else {
        return std::make_pair(malg::real(Q), malg::real(R));
    }
}
#endif

template <typename T>
inline auto lu_decomposition(const MatrixBase<T> &a)
{
    assert(utility::is_square(a) && "Matrix must be square.");
    size_type_t N = a.rows();
    Matrix<T> l(N, N, 0);
    Matrix<T> u(N, N, 0);

    size_type_t i, j, k;
    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            if (j < i)
                l(j, i) = 0;
            else {
                l(j, i) = a(j, i);
                for (k = 0; k < i; k++) {
                    l(j, i) = l(j, i) - l(j, k) * u(k, i);
                }
            }
        }
        for (j = 0; j < N; j++) {
            if (j < i)
                u(i, j) = 0;
            else if (j == i)
                u(i, j) = 1;
            else {
                u(i, j) = a(i, j) / l(i, i);
                for (k = 0; k < i; k++) {
                    u(i, j) = u(i, j) - ((l(i, k) * u(k, j)) / l(i, i));
                }
            }
        }
    }
    return std::make_pair(l, u);
}

template <typename T>
auto solve(const Matrix<T> &A, const Matrix<T> &b)
{
    size_type_t rows = A.rows(), cols = A.cols();
    if (rows == cols) {
        return linalg::inverse(A) * b;
    }
    // Overdetermined system.
    if (rows > cols) {
        auto [_q, _r] = linalg::qr_decomposition(A);
        return linalg::inverse(View(_r, 0, cols, 0, cols)) * (linalg::transpose(View(_q, 0, rows, 0, cols)) * b);
    }
    // Underdetermined system.
    auto At = linalg::transpose(A);
    return (At * linalg::inverse(A * At)) * b;
}

template <typename T1, typename T2>
inline auto div(const MatrixBase<T1> &a, const MatrixBase<T2> &b)
{
    return a * linalg::inverse(b);
}

template <typename T>
inline auto expm(const MatrixBase<T> &A, double accuracy = 0.00001)
{
#if 0
    auto R = utility::zeros<std::remove_const_t<T>>(A.rows(), A.cols());
    for (long k = 0; k <= 50; ++k) {
        R += powm(A, k) / factorial<long double>(k);
    }
    return R;
#else
    // NOTE: use simplified form of "scale and square"
    // Trade faster coversion in power series for a couple of additional square operations
    // TODO: better/faster algorithm than power series?

    // Scale down matrix A by a power of 2, such that norm(A) < 1.
    const auto [iterations, scale] = malg::log2_ceil(A);
    // Apply the scaling.
    const auto scaled_a = A * scale;

    // Compute power series for e^(A/(2^iterations))
    // init (k = 0)
    int batch_size             = A.rows() * A.rows();
    const auto square_accuracy = accuracy * accuracy * scale * scale;
    auto mtk                   = malg::utility::eye<T>(A.rows(), A.cols()); // scaled_a to the power k
    auto ret                   = malg::utility::eye<T>(A.rows(), A.cols()); // sum of power seriees
    auto fac_inv               = double{ 1.0 };                             // inverse faculty
    auto rel_square_diff       = square_accuracy + 1.0;

    for (size_type_t batch_start_idx = 1; (rel_square_diff > square_accuracy && fac_inv != 0.0); batch_start_idx += batch_size) {
        auto local_accum = malg::Matrix<T>(A.rows(), A.cols());
        for (int i = 0; i < batch_size; ++i) {
            const auto k = batch_start_idx + i;
            fac_inv      = fac_inv * (1.0 / k);
            if (feq::approximately_equal(fac_inv, 0.0)) {
                break;
            }
            mtk = mtk * scaled_a;
            local_accum += mtk * fac_inv;
        }
        ret += local_accum;
        // Caclulate relative change in this iteration
        // TODO: properly guard against division by zero
        const malg::Matrix<T> rel_error = malg::linalg::div(local_accum * local_accum, ret * ret + accuracy);
        rel_square_diff                 = malg::square_norm(rel_error);
    };
    // raise the result
    for (size_type_t k = 0; k < iterations; ++k) {
        ret = ret * ret;
    }
    return ret;
#endif
}

} // namespace malg::linalg
